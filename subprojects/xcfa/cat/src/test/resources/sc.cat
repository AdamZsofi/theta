SC

(*************************)
(* Herd standard library *)
(*************************)

(* Empty set of events *)
let emptyset = domain 0

(* Backward compatibility *)
let partition = classes-loc
let tag2instrs = tag2events

(* Aliases *)
let PoD = B
let BR = PoD

(* Basic relations *)
let po-loc = po & loc
let rfe = rf & ext
let rfi = rf & int

(* co0 *)
let co0 = loc & ((IW * (W\IW)) | ((W\FW) * FW))

(* Id relation on set *)
let toid(s) = [s]

(* Turn a fence set into a fence relation *)
let fencerel(B) = (po & (_ * B)) ;  po

(* Control+cfence *)
let ctrlcfence(ctrl,CFENCE) = (ctrl & (_ * CFENCE)) ; po

(* Make the difference between load-reserve/store conditional and amo insructions *)
let lxsx = rmw \ amo

(* Backward compatibility *)
let inv-field = try inv-domain with 0

(* Some utilities (cpp11) *)

let imply (A, B) = ~A | B
(* nodetour eliminates the triangle: *)
(*    .--R2--> c --R3--.             *)
(*   /                  v            *)
(*  a --------R1-------> b           *)

let nodetour (R1, R2, R3) = R1 \ ( R2; R3 )

let singlestep (R) = nodetour(R, R, R)
procedure subseteq(A, B) =
 empty (A \ B)
end

procedure inclusion(r1, r2) =
  empty r1 \ r2
end

procedure total(r,E) =
  let rt = (r | r^-1)
  call inclusion((E*E),rt)
end

(*Union of domain and range*)
let udr r = domain r | range r

(***************)
(* Set library *)
(***************)

(* Apply function f to each member of a set or relation
NOT SUPPORTED
let map f =
  let rec do_map S = match S with
  || {} -> {}
  || e ++ S -> f e ++ do_map S
  end in
  do_map
*)

let LKW = try LKW with emptyset

show (si \ id) \ (I * I) as si


let mfence = try fencerel(MFENCE) with 0
let lfence = try fencerel(LFENCE) with 0
let sfence = try fencerel(SFENCE) with 0

show data,addr,ctrl

(* Fences *)
let dmb.st = try fencerel(DMB.ST) with 0
let dsb.st = try fencerel(DSB.ST) with 0
let dmb = try fencerel(DMB) with 0
let dsb = try fencerel(DSB) with 0
let isb = try fencerel(ISB) with 0
show dmb.st,dsb.st,dmb,dsb

(* Dependencies *)
show data,addr
let ctrlisb = try ctrlcfence(ctrl,ISB) with 0
show ctrlisb
show isb \ ctrlisb as isb
show ctrl \ ctrlisb as ctrl

let sync = try fencerel(SYNC) with 0
let lwsync = try fencerel(LWSYNC) with 0
let eieio = try fencerel(EIEIO) with 0
let isync = try fencerel(ISYNC) with 0
show sync,lwsync,eieio

(* Dependencies *)
show data,addr
let ctrlisync = try ctrlcfence(ctrl,ISYNC) with 0
show ctrlisync
show isync \ ctrlisync as isync
show ctrl \ ctrlisync as ctrl

(* Protection against running tests of other architecture *)
let DMB.ISH = try DMB.ISH with emptyset
let DMB.ISHLD = try DMB.ISHLD with emptyset
let DMB.ISHST = try DMB.ISHST with emptyset
let DSB.ISH = try DSB.ISH with emptyset
let DSB.ISHLD = try DSB.ISHLD with emptyset
let DSB.ISHST = try DSB.ISHST with emptyset
let DMB.SY = try DMB.SY with emptyset
let DMB.ST = try DMB.ST with emptyset
let DMB.LD = try DMB.LD with emptyset
let DSB.SY = try DSB.SY with emptyset
let DSB.ST = try DSB.ST with emptyset
let DSB.LD = try DSB.LD with emptyset
let DMB.OSH = try DMB.OSH with emptyset
let DSB.OSH = try DSB.OSH with emptyset
let DMB.OSHLD = try DMB.OSHLD with emptyset
let DSB.OSHLD = try DSB.OSH with emptyset
let DMB.OSHST = try DMB.OSHST with emptyset
let DSB.OSHST = try DSB.OSHST with emptyset
let ISB = try ISB with emptyset

let A = try A with emptyset
and L = try L with emptyset
and Q = try Q with emptyset
and NoRet = try NoRet with emptyset

(* Fences, for showing *)
let dmb.ish = fencerel(DMB.ISH)
let dmb.ishld = fencerel(DMB.ISHLD)
let dmb.ishst = fencerel(DMB.ISHST)
let dmb.fullsy = fencerel(DMB.SY)
let dmb.fullst = fencerel(DMB.ST)
let dmb.fullld = fencerel(DMB.LD)
let dmb.sy = dmb.fullsy | dmb.ish
let dmb.st = dmb.fullst | dmb.ishst
let dmb.ld = dmb.fullld | dmb.ishld
let dsb.sy = fencerel(DSB.SY)
let dsb.st = fencerel(DSB.ST)
let dsb.ld = fencerel(DSB.LD)
let isb = fencerel(ISB)

show dmb.sy,dmb.st,dmb.ld,dsb.sy,sb.st,dsb.ld,dmb,dsb

(* Correct isb/isync show *)
let ctrlcfence = ctrlisb|ctrlisync
show isync \ ctrlcfence as isync
show isb \ ctrlcfence as isb
show ctrl \ ctrlcfence as ctrl
include "cos.cat"

(* Atomic *)
empty rmw & (fre;coe) as atom

(* Sequential consistency *)
acyclic po | fr | rf | co as sc
